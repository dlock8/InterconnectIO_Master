/**
 * @file    functadv.h
 * @author  Daniel Lockhead
 * @date    2024
 *
 * @brief   Header file defining constants and macros for the complex function
 *
 *
 * @copyright Copyright (c) 2024, D.Lockhead. All rights reserved.
 *
 * This software is licensed under the BSD 3-Clause License.
 * See the LICENSE file for more details.
 */

#ifndef _FUNCTADV_H_
#define _FUNCTADV_H_

#include "hardware/i2c.h"

/** ADC resource definitions */
#define ADC0 26       //!< ADC channel 0
#define ADC1 27       //!< ADC channel 1
#define ADC2 28       //!< ADC channel 2
#define ADC3 29       //!< ADC channel 3
#define ADC_REF 3.0f  //!< Reference voltage generated by device LM4040

/** DAC voltage limits */
#define MINDACVOLT 0    //!< Minimum voltage for the MCP4725 DAC
#define MAXDACVOLT 3.3  //!< Maximum voltage for the MCP4725 DAC

/** Error Flags used on EEPROM */
#define NOERR 0  //!< No error
#define EOOR 1   //!< Flag for error due to data out of range
#define EDE 2    //!< SCPI_ERROR_DEVICE_ERROR
#define ERE 3    //!< SCPI_ERROR_MASS_STORAGE_ERROR
#define ECE 4    //!< SCPI_ERROR_CHARACTER_DATA_ERROR
#define EMP 5    //!< SCPI_ERROR_MISSING_PARAMETER
#define EIVN 6   //!< SCPI_ERROR_ILLEGAL_VARIABLE_NAME
#define ENDE 7   //!< SCPI_ERROR_NUMERIC_DATA_ERROR
#define EBE 8    //!< Read Byte Error

/** EEPROM address definitions */
#define ADD_EEPROM_BASE 0x40  //!< EEPROM base address to start
#define TEST_EEPROM_ADD 0x0   //!< EEPROM address used during self-test
#define EE_PAGESIZE 32        //!< Page size
#define EEMODEL 32            //!< 24LC32 EEPROM model
#define EESIZE 4096           //!< 24LC32 EEPROM size

/** GPIO configuration */
#define GPIO_CTRL_REG (IO_BANK0_BASE + 0x04)  ///< Add (pin * 8)
#define GPIO_CTRL_MPY 8                       ///< Multiply factor for GPIO control

#define GPIO_IRQOVER_BITS 28  ///< 00-11, Default=0
#define GPIO_INOVER_BITS 16   ///< 00-11, Default=0
#define GPIO_OEOVER_BITS 12   ///< 00-11, Default=0
#define GPIO_OUTOVER_BITS 8   ///< 00-11, Default=0
#define GPIO_ALT_BITS 0       ///< 00000-11111, Default=31 (11111)

#define GPIO_ALT_SPI_VAL 1    ///< SPI alternative function value
#define GPIO_ALT_UART_VAL 2   ///< UART alternative function value
#define GPIO_ALT_I2C_VAL 3    ///< I2C alternative function value
#define GPIO_ALT_PWM_VAL 4    ///< PWM alternative function value
#define GPIO_ALT_SIO_VAL 5    ///< SIO alternative function value
#define GPIO_ALT_PIO0_VAL 6   ///< PIO0 alternative function value
#define GPIO_ALT_PIO1_VAL 7   ///< PIO1 alternative function value
#define GPIO_ALT_USB_VAL 9    ///< USB alternative function value
#define GPIO_ALT_NONE_VAL 31  ///< No alternative function

#define GPIO_SYNC_BYPASS_REG (SYSCFG_BASE + 0x0C)  ///< 1=Bypass input sync for that pin

/** GPIO Pad Control */
#define PAD_GPIO_VOLTAGE_REG (PADS_BANK0_BASE + 0x00)  ///< 0 or 1 - covers all pins
#define PAD_GPIO_REG (PADS_BANK0_BASE + 0x04)          ///< Add (pin * 4)
#define PAD_GPIO_MPY 4                                 ///< Multiply factor for GPIO pad

#define PAD_GPIO_SWC_REG (PADS_BANK0_BASE + 0x7C)  ///< SWC register
#define PAD_GPIO_SWD_REG (PADS_BANK0_BASE + 0x80)  ///< SWD register

#define PAD_VOLTAGE_BIT 0  ///< 0=3V3, 1=1V8, Default=0, 3V3
#define PAD_OD_BIT 7       ///< 0=Enable, 1=Disable, Default=0, Output enabled
#define PAD_IE_BIT 6       ///< 0=Disable, 1=Enable, Default=1, Input Enabled
#define PAD_DRIVE_BITS 4   ///< 0=2mA, 1=4mA, 2=8mA, 3=12mA, Default=1, 4mA drive
#define PAD_PUE_BIT 3      ///< 0=Disable, 1=Enable, Default=0, No pull-up
#define PAD_PDE_BIT 2      ///< 0=Disable, 1=Enable, Default=1, Pull-down enabled
#define PAD_SCHMITT_BIT 1  ///< 0=Disable, 1=Enable, Default=1, Schmitt enabled
#define PAD_SLEW_BIT 0     ///< 0=Slow, 1=Fast, Default=0, Slew rate slow

/**
 * @brief Macro to find the minimum of two values.
 *
 * This macro takes two arguments and returns the smaller of the two.
 *
 * @param a First value to compare.
 * @param b Second value to compare.
 * @return The smaller of the two values.
 */
#define min(a, b) ((a) < (b) ? (a) : (b))

uint8_t dac_set(float value, bool save);
float read_master_adc(uint8_t channel);
float read_power(uint8_t mode);
void calibrate_power(float actual, float expected);
uint8_t cfg_eeprom_rw(char mode, uint32_t eeaddr, uint8_t eedatalen, char* data, uint8_t datalen);
void scan_i2c_bus(i2c_inst_t* i2c);
uint8_t cfg_eeprom_read_full();
uint8_t cfg_eeprom_write_default();
uint8_t stringtonumber(const char* str, size_t lgs, long* result);
bool Boot_check(void);
bool IOBoard_Selftest();

#endif  //
